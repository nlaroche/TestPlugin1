# /new-plugin Skill

Scaffold a new BeatConnect VST3/AU plugin project with Web/JUCE 8 hybrid architecture.

## Usage

```
/new-plugin <PluginName>
```

Example: `/new-plugin SuperDelay`

## What This Skill Does

Creates a complete plugin project with:
- **C++ (JUCE 8)** - Audio processing, parameter management, state persistence
- **React/TypeScript** - WebView-based UI with hot reload during development
- **JUCE 8 Relay System** - Native bidirectional parameter sync
- **BeatConnect SDK** - Activation, licensing, and distribution integration
- **CI/CD** - GitHub Actions workflow for automated builds

---

## Build Flags Reference

### CMake Options (Set at Build Time)

| Flag | Type | Description |
|------|------|-------------|
| `{{PLUGIN_NAME_UPPER}}_DEV_MODE` | CMake Option | ON = hot reload from Vite, OFF = bundled assets |
| `BEATCONNECT_ENABLE_ACTIVATION` | CMake Option | ON = link activation SDK, OFF = no activation |

### Compile Definitions (Auto-Set)

| Flag | Value | Description |
|------|-------|-------------|
| `HAS_PROJECT_DATA` | 0 or 1 | 1 if project_data.json exists in resources/ |
| `BEATCONNECT_ACTIVATION_ENABLED` | 0 or 1 | 1 if SDK is linked AND project_data.json exists |
| `JUCE_WEB_BROWSER` | 1 | Required for WebView |
| `JUCE_USE_WIN_WEBVIEW2` | 1 | Required for Windows WebView2 |

### Runtime Flags (From project_data.json)

| Flag | Type | Description |
|------|------|-------------|
| `enableActivationKeys` | bool | Whether activation is required |
| `debugMode` | bool | Enable debug logging |

---

## project_data.json Structure

This file is **injected by BeatConnect CI** at build time. It contains:

```json
{
  "pluginId": "fd5cf09b-b8f4-495c-a4b9-8404dd965b4c",
  "apiBaseUrl": "https://xxx.supabase.co/functions/v1",
  "supabasePublishableKey": "sb_publishable_xxx",
  "flags": {
    "enableActivationKeys": true,
    "debugMode": false
  },
  "_meta": {
    "name": "MyPlugin",
    "version": "1.0.0"
  }
}
```

**Important:** This file is NOT in the repo. It's generated by the BeatConnect build system and embedded as BinaryData.

---

## Activation System Integration

### PluginProcessor Setup

```cpp
// PluginProcessor.h
#if HAS_PROJECT_DATA
#include "ProjectData.h"  // Generated BinaryData
#endif

class MyPluginProcessor : public juce::AudioProcessor
{
    // BeatConnect project data
    juce::String pluginId_;
    juce::String apiBaseUrl_;
    juce::String supabasePublishableKey_;
    juce::var buildFlags_;

    void loadProjectData();
    bool hasActivationEnabled() const;
};
```

```cpp
// PluginProcessor.cpp
#if BEATCONNECT_ACTIVATION_ENABLED
#include <beatconnect/Activation.h>
#endif

MyPluginProcessor::MyPluginProcessor()
{
    loadProjectData();  // Load and configure activation
}

void MyPluginProcessor::loadProjectData()
{
#if HAS_PROJECT_DATA
    int dataSize = 0;
    const char* data = ProjectData::getNamedResource("project_data_json", dataSize);

    if (data == nullptr || dataSize == 0) return;

    auto parsed = juce::JSON::parse(juce::String::fromUTF8(data, dataSize));
    if (parsed.isVoid()) return;

    // Extract BeatConnect configuration
    pluginId_ = parsed.getProperty("pluginId", "").toString();
    apiBaseUrl_ = parsed.getProperty("apiBaseUrl", "").toString();
    supabasePublishableKey_ = parsed.getProperty("supabasePublishableKey", "").toString();
    buildFlags_ = parsed.getProperty("flags", juce::var());

#if BEATCONNECT_ACTIVATION_ENABLED
    bool enableActivation = static_cast<bool>(buildFlags_.getProperty("enableActivationKeys", false));

    if (enableActivation && pluginId_.isNotEmpty())
    {
        beatconnect::ActivationConfig config;
        config.apiBaseUrl = apiBaseUrl_.toStdString();
        config.pluginId = pluginId_.toStdString();
        config.supabaseKey = supabasePublishableKey_.toStdString();
        beatconnect::Activation::getInstance().configure(config);
    }
#endif
#endif
}

bool MyPluginProcessor::hasActivationEnabled() const
{
#if HAS_PROJECT_DATA && BEATCONNECT_ACTIVATION_ENABLED
    return static_cast<bool>(buildFlags_.getProperty("enableActivationKeys", false));
#else
    return false;
#endif
}
```

### PluginEditor Activation Events

```cpp
// PluginEditor.cpp - Setup web event listeners
void MyPluginEditor::setupActivationEvents()
{
#if BEATCONNECT_ACTIVATION_ENABLED
    // Listen for activation requests from web UI
    webView->addListener("activatePlugin", [this](const juce::var& data) {
        auto code = data.getProperty("code", "").toString().toStdString();

        beatconnect::Activation::getInstance().activateAsync(code,
            [safeThis = juce::Component::SafePointer(this)](beatconnect::ActivationStatus status) {
                if (safeThis == nullptr) return;

                juce::MessageManager::callAsync([safeThis, status]() {
                    if (safeThis == nullptr) return;
                    safeThis->sendActivationResult(status);
                });
            });
    });

    // Listen for deactivation requests
    webView->addListener("deactivatePlugin", [this](const juce::var&) {
        auto status = beatconnect::Activation::getInstance().deactivate();
        sendActivationResult(status);
    });
#endif
}

void MyPluginEditor::sendActivationState()
{
#if BEATCONNECT_ACTIVATION_ENABLED
    auto& activation = beatconnect::Activation::getInstance();

    juce::DynamicObject::Ptr data = new juce::DynamicObject();
    data->setProperty("isActivated", activation.isActivated());
    data->setProperty("requiresActivation", processorRef.hasActivationEnabled());

    if (auto info = activation.getActivationInfo())
    {
        data->setProperty("activationCode", juce::String(info->activationCode));
        data->setProperty("expiresAt", juce::String(info->expiresAt));
    }

    webView->emitEventIfBrowserIsVisible("activationState", juce::var(data.get()));
#else
    // No activation - always "activated"
    juce::DynamicObject::Ptr data = new juce::DynamicObject();
    data->setProperty("isActivated", true);
    data->setProperty("requiresActivation", false);
    webView->emitEventIfBrowserIsVisible("activationState", juce::var(data.get()));
#endif
}
```

### TypeScript Activation Handling

```typescript
// hooks/useActivation.ts
import { useEffect, useState } from 'react';

interface ActivationState {
  isActivated: boolean;
  requiresActivation: boolean;
  activationCode?: string;
  expiresAt?: string;
}

export function useActivation() {
  const [state, setState] = useState<ActivationState>({
    isActivated: true,
    requiresActivation: false
  });
  const [isActivating, setIsActivating] = useState(false);

  useEffect(() => {
    if (!window.__JUCE__?.backend) return;

    window.__JUCE__.backend.addEventListener('activationState', (data: ActivationState) => {
      setState(data);
    });

    window.__JUCE__.backend.addEventListener('activationResult', (data: any) => {
      setIsActivating(false);
      if (data.success) {
        setState(prev => ({ ...prev, isActivated: true }));
      }
    });
  }, []);

  const activate = (code: string) => {
    setIsActivating(true);
    window.__JUCE__?.backend?.emitEvent('activatePlugin', { code });
  };

  const deactivate = () => {
    window.__JUCE__?.backend?.emitEvent('deactivatePlugin', {});
  };

  return { ...state, activate, deactivate, isActivating };
}
```

---

## Step-by-Step Process

### Phase 1: Gather Information

Before creating files, ask the user:

1. **Plugin Name** (if not provided): PascalCase name (e.g., "SuperDelay")
2. **Plugin Type**: Effect or Instrument
3. **Initial Parameters**: What parameters should the plugin have?
4. **Company Name**: Default to "BeatConnect"

### Phase 2: Create Project Structure

```
<plugin-name>/
├── CMakeLists.txt
├── Source/
│   ├── PluginProcessor.cpp
│   ├── PluginProcessor.h
│   ├── PluginEditor.cpp
│   ├── PluginEditor.h
│   └── ParameterIDs.h
├── web-ui/
│   ├── package.json
│   ├── vite.config.ts
│   ├── index.html
│   └── src/
│       ├── main.tsx
│       ├── App.tsx
│       ├── index.css
│       ├── lib/
│       │   └── juce-bridge.ts
│       └── hooks/
│           ├── useJuceParam.ts
│           └── useActivation.ts
├── beatconnect-sdk/              # Git submodule
└── .github/workflows/build.yml
```

### Phase 3: Replace Placeholders

Replace in ALL files:
- `{{PLUGIN_NAME}}` → PascalCase (e.g., "SuperDelay")
- `{{PLUGIN_NAME_UPPER}}` → SCREAMING_SNAKE (e.g., "SUPER_DELAY")
- `{{COMPANY_NAME}}` → Company name (e.g., "BeatConnect")
- `{{COMPANY_NAME_LOWER}}` → lowercase (e.g., "beatconnect")
- `{{PLUGIN_CODE}}` → Unique 4 chars (e.g., "Sdly")
- `{{MANUFACTURER_CODE}}` → 4 chars (e.g., "Beat")

### Phase 4: Configure CMakeLists.txt

Ensure these sections are present:

```cmake
# Dev mode option
option({{PLUGIN_NAME_UPPER}}_DEV_MODE "Enable development mode" OFF)

# Plugin target with WebView2
juce_add_plugin(${PROJECT_NAME}
    NEEDS_WEBVIEW2 TRUE
    # ... other options
)

# Compile definitions
target_compile_definitions(${PROJECT_NAME}
    PUBLIC
        JUCE_WEB_BROWSER=1
        $<IF:$<BOOL:${${PROJECT_NAME}_DEV_MODE}>,${PROJECT_NAME}_DEV_MODE=1,${PROJECT_NAME}_DEV_MODE=0>
)

# Windows WebView2
if(WIN32)
    target_compile_definitions(${PROJECT_NAME} PUBLIC JUCE_USE_WIN_WEBVIEW2=1)
endif()

# BeatConnect SDK Integration
option(BEATCONNECT_ENABLE_ACTIVATION "Enable activation" OFF)

if(EXISTS "${CMAKE_SOURCE_DIR}/resources/project_data.json")
    juce_add_binary_data(${PROJECT_NAME}_BinaryData
        HEADER_NAME "ProjectData.h"
        NAMESPACE ProjectData
        SOURCES resources/project_data.json
    )
    target_link_libraries(${PROJECT_NAME} PRIVATE ${PROJECT_NAME}_BinaryData)
    target_compile_definitions(${PROJECT_NAME} PUBLIC HAS_PROJECT_DATA=1)
else()
    target_compile_definitions(${PROJECT_NAME} PUBLIC HAS_PROJECT_DATA=0)
endif()

if(BEATCONNECT_ENABLE_ACTIVATION AND EXISTS "${CMAKE_SOURCE_DIR}/beatconnect-sdk/sdk/activation/CMakeLists.txt")
    add_subdirectory(beatconnect-sdk/sdk/activation)
    target_link_libraries(${PROJECT_NAME} PRIVATE beatconnect_activation)
    target_compile_definitions(${PROJECT_NAME} PUBLIC BEATCONNECT_ACTIVATION_ENABLED=1)
else()
    target_compile_definitions(${PROJECT_NAME} PUBLIC BEATCONNECT_ACTIVATION_ENABLED=0)
endif()
```

---

## Validation Checklists

### C++ Checklist

- [ ] All relays created BEFORE WebBrowserComponent
- [ ] All relays added to WebView options with `.withOptionsFrom()`
- [ ] All attachments created AFTER WebView
- [ ] Parameter IDs in ParameterIDs.h match relay names exactly
- [ ] State versioning implemented (`kStateVersion` constant)
- [ ] Variable buffer size handling (2x headroom in prepareToPlay)
- [ ] Smoothed values reset on bypass
- [ ] `loadProjectData()` called in processor constructor
- [ ] `#if BEATCONNECT_ACTIVATION_ENABLED` guards around activation code
- [ ] `#if HAS_PROJECT_DATA` guards around ProjectData includes

### TypeScript Checklist

- [ ] All parameter IDs match C++ exactly (case-sensitive)
- [ ] useSliderParam/useToggleParam/useComboParam hooks for each parameter
- [ ] dragStart/dragEnd wired for slider controls
- [ ] useActivation hook implemented
- [ ] Activation UI shows when `requiresActivation && !isActivated`

### CMakeLists.txt Checklist

- [ ] `NEEDS_WEBVIEW2 TRUE` in juce_add_plugin
- [ ] `JUCE_WEB_BROWSER=1` defined
- [ ] `JUCE_USE_WIN_WEBVIEW2=1` for Windows
- [ ] Dev mode option and compile definition
- [ ] `BEATCONNECT_ENABLE_ACTIVATION` option
- [ ] `HAS_PROJECT_DATA` logic for project_data.json
- [ ] `BEATCONNECT_ACTIVATION_ENABLED` logic for SDK
- [ ] BinaryData target for project_data.json
- [ ] beatconnect_activation linked when enabled

### Build System Checklist

- [ ] beatconnect-sdk added as git submodule
- [ ] .github/workflows/build.yml configured
- [ ] Web build runs before C++ build in CI
- [ ] Resources copied to plugin bundle
- [ ] project_data.json injection point in CI

---

## Common Mistakes to Avoid

1. **Creating WebBrowserComponent before relays** - Relays MUST exist first
2. **Mismatched parameter identifiers** - "gain" in C++ must match "gain" in TypeScript
3. **Using postMessage for parameters** - Use relay system instead
4. **Forgetting NEEDS_WEBVIEW2** - Required for Windows
5. **No state versioning** - Causes crashes on parameter changes between versions
6. **Smoothed values not reset on bypass** - Causes clicks when re-enabling
7. **Fixed buffer sizes** - Causes crackling in FL Studio and other DAWs
8. **Missing #if guards** - Activation code without guards breaks non-activation builds
9. **Hardcoding activation URLs** - Must come from project_data.json

---

## Development Workflow

### Local Development (No Activation)

```bash
# Terminal 1: Start web dev server
cd web-ui && npm install && npm run dev

# Terminal 2: Build plugin in dev mode
cmake -B build -D{{PLUGIN_NAME_UPPER}}_DEV_MODE=ON
cmake --build build

# Run standalone - connects to localhost:5173
```

### Testing Activation Locally

1. Create `resources/project_data.json` manually with test values
2. Build with activation enabled:
```bash
cmake -B build -DBEATCONNECT_ENABLE_ACTIVATION=ON
cmake --build build
```

### Production Build

```bash
cd web-ui && npm run build
cmake -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build --config Release
```

---

## Reference

- Full patterns documentation: `beatconnect-sdk/docs/patterns.md`
- SDK documentation: `beatconnect-sdk/CLAUDE.md`
- Templates: `beatconnect-sdk/templates/`
- Activation API: `beatconnect-sdk/sdk/activation/include/beatconnect/Activation.h`
